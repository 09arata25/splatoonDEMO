<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D Ink Shooter - Triple Tornado Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: sans-serif; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; pointer-events: none; text-shadow: 1px 1px 2px black; line-height: 1.4; }
        #weapon-ui { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: white; background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 20px; border: 2px solid #00ff00; }
        #special-ui { position: absolute; top: 10px; right: 10px; width: 200px; height: 30px; background: rgba(0,0,0,0.5); border: 2px solid white; }
        #special-bar { width: 0%; height: 100%; background: #00ff00; transition: width 0.1s; box-shadow: 0 0 15px #00ff00; }
        #special-hint { position: absolute; top: 45px; right: 10px; color: #00ff00; font-weight: bold; display: none; text-shadow: 1px 1px 2px black; animation: blink 0.5s infinite alternate; }
        #special-count { position: absolute; top: 70px; right: 10px; color: #fff; font-size: 24px; font-weight: bold; display: none; }
        @keyframes blink { from { opacity: 1; } to { opacity: 0.5; } }
       /* ===== タッチUI共通 ===== */
#touch-controls{
    position: fixed;
    inset: 0;
    pointer-events: none;
    user-select: none;
}

/* ボタン共通 */
.touch-btn{
    pointer-events: auto;
    width: 14vmin;
    height: 14vmin;
    max-width: 70px;
    max-height: 70px;
    display:flex;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.5);
    color:white;
    border-radius:50%;
    border:2px solid white;
    font-weight:bold;
    font-size: clamp(12px,2.5vmin,18px);
}

/* ===== 左ジョイスティック ===== */
#joystick-base{
    position:absolute;
    left: calc(3vmin + env(safe-area-inset-left));
    bottom: calc(3vmin + env(safe-area-inset-bottom));
    width:22vmin;
    height:22vmin;
    max-width:130px;
    max-height:130px;
    pointer-events:auto;
}

/* ===== 右ボタン群 ===== */
#touch-controls > div:nth-child(2){
    position:absolute;
    right: calc(3vmin + env(safe-area-inset-right));
    bottom: calc(3vmin + env(safe-area-inset-bottom));
}

/* ===== 武器ボタン ===== */
#touch-controls > div:nth-child(3){
    position:absolute;
    left:50%;
    bottom: calc(12vmin + env(safe-area-inset-bottom));
    transform: translateX(-50%);
}

        #crosshair { position: absolute; top: 50%; left: 50%; width: 24px; height: 24px; border: 3px solid rgba(255,255,255,0.9); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }
    </style>
</head>
<body>
    <div id="ui">
        <b>WASD</b>: 移動 | <b>Shift</b>: 潜伏・壁登り<br>
        <b>左クリック</b>: 攻撃 | <b>右クリック / Q</b>: ボム<br>
        <b>Space</b>: ジャンプ | <b>E</b>: スペシャル | <b>I / O</b>: ズーム<br>
        <b>1</b>: シューター | <b>2</b>: ローラー
    </div>
    <div id="weapon-ui">WEAPON: <span id="weapon-name">SHOOTER</span></div>
    <div id="special-ui"><div id="special-bar"></div></div>
    <div id="special-hint">SPECIAL READY (E)</div>
    <div id="special-count">TORNADO: 3</div>
    <div id="crosshair"></div>
    <div id="touch-controls">
        <div id="joystick-base" style="position: absolute; left: 30px; bottom: 30px; width: 120px; height: 120px; background: rgba(255,255,255,0.2); border-radius: 50%; border: 1px solid rgba(255,255,255,0.4);">
            <div id="joystick-stick" style="position: absolute; left: 35px; top: 35px; width: 50px; height: 50px; background: rgba(255,255,255,0.6); border-radius: 50%;"></div>
        </div>
        <div style="position: absolute; right: 20px; bottom: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div id="btn-sub" class="touch-btn">BOMB</div>
            <div id="btn-jump" class="touch-btn">JUMP</div>
            <div id="btn-shift" class="touch-btn" style="background: rgba(0,255,0,0.2);">INK</div>
            <div id="btn-special" class="touch-btn" style="border-color: #00ff00; color: #00ff00;">SP</div>
        </div>
        <div style="position: absolute; left: 50%; bottom: 80px; transform: translateX(-50%); display: flex; gap: 20px;">
            <div id="btn-w1" style="padding: 10px 20px; background: rgba(0,0,0,0.5); color: white; border: 1px solid white;">1</div>
            <div id="btn-w2" style="padding: 10px 20px; background: rgba(0,0,0,0.5); color: white; border: 1px solid white;">2</div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- 設定 ---
        const INK_COLOR = "#00ff00";
        const FIELD_SIZE = 300;
        const CANVAS_RES = 1024;
        const paintableObjects = [];
        const bullets = [];
        const bombs = [];
        const tornadoes = [];
        let specialPoints = 0;
        const SPECIAL_MAX = 100;
        let isSpecialActive = false;
        let tornadoStock = 0; // トルネードの残り弾数
        
        let currentWeapon = 'shooter';
        const ROLLER_WIDTH = 2.2; 
        let lastRollerSwingTime = 0; 

        // --- オーディオシステム ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(freq, type, volume, duration, slide = 0) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, now);
            if (slide > 0) osc.frequency.exponentialRampToValueAtTime(slide, now + duration);
            gain.gain.setValueAtTime(volume, now);
            gain.gain.linearRampToValueAtTime(0, now + duration);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(now + duration);
        }

        function playShootSound() { playSound(400, 'triangle', 0.15, 0.1, 10); }
        function playRollerSwingSound() { playSound(150, 'sawtooth', 0.2, 0.3, 10); }
        function playExplosionSound() { playSound(120, 'sine', 0.6, 0.5, 0.01); }
        function playSpecialCharge() { playSound(150, 'sawtooth', 0.4, 0.8, 900); }
        function playTornadoSound() { playSound(60, 'brown', 0.3, 1.5, 300); }
        function playSpecialExplosion() {
            const now = audioCtx.currentTime;
            playSound(40, 'sine', 1.2, 2.5, 1);
            playSound(60, 'square', 0.8, 1.2, 20);
            playSound(150, 'sawtooth', 0.6, 0.5, 10);
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(10, now + 2.0);
            g.gain.setValueAtTime(0.3, now);
            g.gain.linearRampToValueAtTime(0, now + 2.0);
            osc.connect(g); g.connect(audioCtx.destination);
            osc.start(); osc.stop(now + 2.0);
        }

        // --- シーン構築 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(100, 200, 100);
        scene.add(dirLight);

        function createPaintable(geometry, x, y, z, rotX = 0, rotY = 0, isWall = false, worldSize = 10) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = CANVAS_RES;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.fillStyle = isWall ? "#555" : "#bbb";
            ctx.fillRect(0, 0, CANVAS_RES, CANVAS_RES);
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.9 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.rotation.set(rotX, rotY, 0);
            mesh.userData = { ctx, texture, isWall, worldSize };
            scene.add(mesh);
            paintableObjects.push(mesh);
            return mesh;
        }

        function createBuilding(x, z, w, h, d) {
            createPaintable(new THREE.PlaneGeometry(w, h), x, h/2, z + d/2, 0, 0, true, w); 
            createPaintable(new THREE.PlaneGeometry(w, h), x, h/2, z - d/2, 0, Math.PI, true, w); 
            createPaintable(new THREE.PlaneGeometry(d, h), x + w/2, h/2, z, 0, Math.PI/2, true, d); 
            createPaintable(new THREE.PlaneGeometry(d, h), x - w/2, h/2, z, 0, -Math.PI/2, true, d); 
            createPaintable(new THREE.PlaneGeometry(w, d), x, h, z, -Math.PI/2, 0, true, w); 
        }

        createPaintable(new THREE.PlaneGeometry(FIELD_SIZE, FIELD_SIZE), 0, 0, 0, -Math.PI / 2, 0, false, FIELD_SIZE);
        createBuilding(0, -50, 40, 20, 40);
        createBuilding(60, 30, 30, 15, 30);
        createBuilding(-60, 40, 20, 30, 20);

        const player = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.8, 0.8), new THREE.MeshStandardMaterial({ color: 0xff4400 }));
        body.position.y = 0.9;
        player.add(body);
        scene.add(player);

        const weaponHolder = new THREE.Group();
        weaponHolder.position.set(0.8, 1.2, -0.5);
        player.add(weaponHolder);

        const shooterModel = new THREE.Group();
        const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.2), new THREE.MeshStandardMaterial({color: 0x333}));
        const gunTank = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.6), new THREE.MeshStandardMaterial({color: INK_COLOR}));
        gunTank.rotation.x = Math.PI/2; gunTank.position.z = -0.2; gunTank.position.y = 0.3;
        shooterModel.add(gunBody, gunTank);
        weaponHolder.add(shooterModel);

        const rollerModel = new THREE.Group();
        const rollerCylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, ROLLER_WIDTH * 2), new THREE.MeshStandardMaterial({color: INK_COLOR}));
        rollerCylinder.rotation.z = Math.PI/2;
        const rollerHandle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 2.5), new THREE.MeshStandardMaterial({color: 0x555}));
        rollerHandle.position.z = 1.25;
        rollerModel.add(rollerCylinder, rollerHandle);
        rollerModel.position.set(-0.8, 0, -2);
        weaponHolder.add(rollerModel);

        const cameraHolder = new THREE.Group();
        cameraHolder.position.y = 1.8;
        player.add(cameraHolder);
        cameraHolder.add(camera);
        camera.position.set(0, 0.5, 6);

        let move = { fwd: false, bwd: false, lft: false, rgt: false };
        let isShooting = false, isSubmerged = false, yVelocity = 0, pitch = 0;
        // --- スマホ操作ロジックここから ---
        const isTouchDevice = 'ontouchstart' in window;
        if (isTouchDevice) {
            document.getElementById('touch-controls').style.display = 'block';
            document.getElementById('ui').style.display = 'none';
        }

        let joyX = 0, joyY = 0;
        const stick = document.getElementById('joystick-stick');
        const base = document.getElementById('joystick-base');

        base.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = base.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.min(60, Math.sqrt(dx*dx + dy*dy));
            const angle = Math.atan2(dy, dx);
            joyX = (Math.cos(angle) * dist) / 60;
            joyY = (Math.sin(angle) * dist) / 60;
            stick.style.transform = `translate(${joyX * 40}px, ${joyY * 40}px)`;
            move.fwd = joyY < -0.3; move.bwd = joyY > 0.3;
            move.lft = joyX < -0.3; move.rgt = joyX > 0.3;
        }, {passive: false});

        base.addEventListener('touchend', () => {
            joyX = 0; joyY = 0;
            stick.style.transform = `translate(0px, 0px)`;
            move.fwd = move.bwd = move.lft = move.rgt = false;
        });

        let lastTouchX = 0, lastTouchY = 0;
        window.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            if (touch.clientX > window.innerWidth / 2) {
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                if (tornadoStock > 0) throwTornado();
                else isShooting = true;
            }
        });

        window.addEventListener('touchmove', (e) => {
            const touch = Array.from(e.touches).find(t => t.clientX > window.innerWidth / 2);
            if (touch) {
                const dx = touch.clientX - lastTouchX;
                const dy = touch.clientY - lastTouchY;
                player.rotation.y -= dx * 0.008;
                pitch -= dy * 0.005;
                pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, pitch));
                cameraHolder.rotation.x = pitch;
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
            }
        }, {passive: false});

        window.addEventListener('touchend', (e) => {
            if (Array.from(e.touches).filter(t => t.clientX > window.innerWidth / 2).length === 0) {
                isShooting = false;
            }
        });

        // 各ボタンの機能割り当て
        const setupBtn = (id, startFn, endFn) => {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', (e) => { e.preventDefault(); startFn(); });
            if(endFn) el.addEventListener('touchend', (e) => { e.preventDefault(); endFn(); });
        };

        setupBtn('btn-jump', () => { if(player.position.y <= 0.1) yVelocity = 0.25; });
        setupBtn('btn-sub', throwBomb);
        setupBtn('btn-special', activateSpecial);
        setupBtn('btn-shift', () => isSubmerged = true, () => isSubmerged = false);
        setupBtn('btn-w1', () => { currentWeapon = 'shooter'; document.getElementById('weapon-name').innerText = 'SHOOTER'; });
        setupBtn('btn-w2', () => { currentWeapon = 'roller'; document.getElementById('weapon-name').innerText = 'ROLLER'; });
        // --- スマホ操作ロジックここまで ---
        const raycaster = new THREE.Raycaster();

        function updateSpecialUI() {
            const bar = document.getElementById('special-bar');
            const hint = document.getElementById('special-hint');
            const countDisplay = document.getElementById('special-count');
            const percent = Math.min(100, (specialPoints / SPECIAL_MAX) * 100);
            bar.style.width = percent + '%';
            hint.style.display = (percent >= 100 && !isSpecialActive) ? 'block' : 'none';
            
            if (tornadoStock > 0) {
                countDisplay.style.display = 'block';
                countDisplay.innerText = `TORNADO: ${tornadoStock}`;
            } else {
                countDisplay.style.display = 'none';
            }
        }

        window.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') move.fwd = true;
            if(e.code === 'KeyS') move.bwd = true;
            if(e.code === 'KeyA') move.lft = true;
            if(e.code === 'KeyD') move.rgt = true;
            if(e.code === 'KeyQ') throwBomb();
            if(e.code === 'KeyE') activateSpecial();
            if(e.code === 'Space' && player.position.y <= 0.1) yVelocity = 0.25;
            if(e.code === 'ShiftLeft') isSubmerged = true;
            if(e.code === 'KeyO') camera.position.z = Math.min(camera.position.z + 0.5, 15);
            if(e.code === 'KeyI') camera.position.z = Math.max(camera.position.z - 0.5, 0.1);
            if(e.code === 'Digit1') { currentWeapon = 'shooter'; document.getElementById('weapon-name').innerText = 'SHOOTER'; }
            if(e.code === 'Digit2') { currentWeapon = 'roller'; document.getElementById('weapon-name').innerText = 'ROLLER'; }
        });
        window.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') move.fwd = false;
            if(e.code === 'KeyS') move.bwd = false;
            if(e.code === 'KeyA') move.lft = false;
            if(e.code === 'KeyD') move.rgt = false;
            if(e.code === 'ShiftLeft') isSubmerged = false;
        });
        document.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                if (tornadoStock > 0) {
                    throwTornado();
                    return;
                }
                isShooting = true;
                if (currentWeapon === 'roller' && !isSubmerged && !isSpecialActive) {
                    const now = Date.now();
                    if (now - lastRollerSwingTime > 500) { 
                        if (player.position.y > 0.2) rollerSwing('vertical');
                        else rollerSwing('horizontal');
                        lastRollerSwingTime = now;
                    }
                }
            }
            if (e.button === 2) throwBomb();
        });
        document.addEventListener('mouseup', (e) => { if (e.button === 0) isShooting = false; });
        document.addEventListener('click', () => renderer.domElement.requestPointerLock());
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === renderer.domElement) {
                player.rotation.y -= e.movementX * 0.003;
                pitch -= e.movementY * 0.002;
                pitch = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, pitch));
                cameraHolder.rotation.x = pitch;
            }
        });

        function paintAt(obj, uv, sizeFactor = 1) {
            const { ctx, texture, worldSize } = obj.userData;
            if (!uv) return;
            const u = uv.x * CANVAS_RES, v = (1 - uv.y) * CANVAS_RES;
            const pixelRadius = (4 * sizeFactor / worldSize) * CANVAS_RES;
            ctx.fillStyle = INK_COLOR;
            ctx.beginPath(); ctx.arc(u, v, pixelRadius, 0, Math.PI * 2); ctx.fill();
            texture.needsUpdate = true;
            // スペシャル発動中、またはトルネードが場に残っている間はゲージを溜めない
            if (!isSpecialActive && tornadoStock === 0 && tornadoes.length === 0) { 
                specialPoints += 0.25 * sizeFactor; 
                updateSpecialUI(); 
            }
        }

        function checkInkColor(obj, uv) {
            if (!uv) return false;
            const { ctx } = obj.userData;
            const u = Math.floor(uv.x * CANVAS_RES), v = Math.floor((1 - uv.y) * CANVAS_RES);
            const data = ctx.getImageData(u, v, 1, 1).data;
            return data[1] > 140 && data[0] < 100;
        }

        function throwBomb() {
            if (isSubmerged || isSpecialActive || tornadoStock > 0) return;
            const bomb = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({ color: INK_COLOR, emissive: INK_COLOR, emissiveIntensity: 0.5 }));
            bomb.position.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));
            const targetDir = new THREE.Vector3(); camera.getWorldDirection(targetDir);
            bomb.userData = { velocity: targetDir.multiplyScalar(0.8).add(new THREE.Vector3(0, 0.4, 0)), timer: 0, life: 1.5 };
            scene.add(bomb); bombs.push(bomb);
        }

        function throwTornado() {
            if (tornadoStock <= 0) return;
            tornadoStock--;
            updateSpecialUI();
            playSpecialCharge();

            const ball = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: INK_COLOR, emissiveIntensity: 2 }));
            ball.position.copy(player.position).add(new THREE.Vector3(0, 2, 0));
            const targetDir = new THREE.Vector3(); camera.getWorldDirection(targetDir);
            const vel = targetDir.multiplyScalar(1.2).add(new THREE.Vector3(0, 0.3, 0));
            scene.add(ball);
            
            let ballActive = true;
            const ballUpdate = () => {
                if(!ballActive) return;
                ball.position.add(vel);
                vel.y -= 0.03;
                raycaster.set(ball.position, vel.clone().normalize());
                const hits = raycaster.intersectObjects(paintableObjects);
                if (hits.length > 0 && hits[0].distance < 1.0 || ball.position.y < 0) {
                    createTornado(ball.position);
                    scene.remove(ball);
                    ballActive = false;
                } else {
                    requestAnimationFrame(ballUpdate);
                }
            };
            ballUpdate();
        }

        function rollerSwing(type) {
            playRollerSwingSound();
            const count = type === 'horizontal' ? 12 : 8;
            for (let i = 0; i < count; i++) {
                const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({ color: INK_COLOR }));
                bullet.position.copy(player.position).add(new THREE.Vector3(0, 1.2, 0));
                const targetDir = new THREE.Vector3(); camera.getWorldDirection(targetDir);
                const offset = (i - count / 2) / count;
                const right = new THREE.Vector3().crossVectors(targetDir, new THREE.Vector3(0,1,0)).normalize();
                const up = new THREE.Vector3().crossVectors(right, targetDir).normalize();
                if (type === 'horizontal') targetDir.add(right.multiplyScalar(offset * 1.5)).add(up.multiplyScalar(0.2));
                else targetDir.add(up.multiplyScalar(offset * 1.2)).add(right.multiplyScalar(0.1));
                bullet.userData.velocity = targetDir.normalize().multiplyScalar(1.2);
                scene.add(bullet); bullets.push(bullet);
            }
        }

        function createSplashParticle(pos, customSize = 0.5) {
            const group = new THREE.Group();
            for(let i=0; i<40; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(Math.random() * customSize + 0.2), new THREE.MeshStandardMaterial({ color: INK_COLOR, emissive: INK_COLOR }));
                const phi = Math.random() * Math.PI * 2, theta = Math.random() * Math.PI, speed = (Math.random() * 1.5 + 0.5) * (customSize * 1.5);
                p.userData.vel = new THREE.Vector3(Math.sin(theta) * Math.cos(phi) * speed, Math.cos(theta) * speed + 0.5, Math.sin(theta) * Math.sin(phi) * speed);
                group.add(p);
            }
            group.position.copy(pos); scene.add(group);
            let life = 1.0;
            const anim = () => { life -= 0.02; group.children.forEach(p => { p.position.add(p.userData.vel); p.userData.vel.y -= 0.05; p.scale.multiplyScalar(0.95); }); if(life > 0) requestAnimationFrame(anim); else scene.remove(group); };
            anim();
        }

async function createTornado(pos) {
            playTornadoSound();
            const tornadoGroup = new THREE.Group();
            // 視覚的な太さをさらにスリムに (半径 4)
            const geom = new THREE.CylinderGeometry(4.5, 4.5, 1000, 20, 1, true);
            const mat = new THREE.MeshBasicMaterial({ color: INK_COLOR, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            const cylinder = new THREE.Mesh(geom, mat);
            cylinder.position.y = 500; 
            tornadoGroup.add(cylinder);
            
            const core = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.0, 1000, 8), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 }));
            core.position.y = 500;
            tornadoGroup.add(core);

            tornadoGroup.position.copy(pos);
            scene.add(tornadoGroup);
            tornadoes.push(tornadoGroup);

            let startTime = Date.now();
            const duration = 1500;

            const update = () => {
                const elapsed = Date.now() - startTime;
                cylinder.rotation.y += 0.5;
                core.rotation.y -= 0.8;
                
                // --- 最小・最速の貫通塗りロジック ---
                const TORNADO_LIMIT = 4; // 判定半径を4まで縮小
                
                paintableObjects.forEach(obj => {
                    const dx = obj.position.x - pos.x;
                    const dz = obj.position.z - pos.z;
                    const distXZ = Math.sqrt(dx * dx + dz * dz);

                    if (distXZ < TORNADO_LIMIT + (obj.userData.worldSize / 2)) {
                        // スキャン地点を中心からごくわずかな範囲に限定
                        const scanPoints = [
                            new THREE.Vector3(0, 0, 0),
                            new THREE.Vector3(1.5, 0, 0),
                            new THREE.Vector3(-1.5, 0, 0),
                            new THREE.Vector3(0, 0, 1.5),
                            new THREE.Vector3(0, 0, -1.5)
                        ];

                        scanPoints.forEach(offset => {
                            const scanPos = pos.clone().add(offset);

                            // 1. 【上下貫通スキャン】
                            raycaster.set(scanPos.setY(500), new THREE.Vector3(0, -1, 0));
                            raycaster.far = 1000;
                            const vHits = raycaster.intersectObject(obj);
                            // 塗りサイズを 2.5 に絞り、はみ出しを極限までカット
                            vHits.forEach(hit => paintAt(hit.object, hit.uv, 2.5));

                            // 2. 【壁の制圧】
                            for (let h = 0; h <= 60; h += 8) {
                                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                                    const dir = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                                    raycaster.set(pos.clone().setY(h), dir);
                                    raycaster.far = TORNADO_LIMIT; 
                                    const wallHits = raycaster.intersectObject(obj);
                                    wallHits.forEach(hit => paintAt(hit.object, hit.uv, 2.0));
                                }
                            }
                        });
                    }
                });

                if (elapsed < duration) {
                    requestAnimationFrame(update);
                } else {
                    createSplashParticle(pos, 20); // パーティクルも控えめに
                    scene.remove(tornadoGroup);
                    const idx = tornadoes.indexOf(tornadoGroup);
                    if (idx !== -1) tornadoes.splice(idx, 1);
                    updateSpecialUI();
                }
            };
            update();
        }

        async function activateSpecial() {
            if (specialPoints < SPECIAL_MAX || isSpecialActive || tornadoStock > 0) return;
            isSpecialActive = true; 
            specialPoints = 0; 
            updateSpecialUI();

            if (currentWeapon === 'shooter') {
                playSpecialCharge();
                const fistMat = new THREE.MeshStandardMaterial({ color: INK_COLOR, emissive: INK_COLOR, emissiveIntensity: 2 });
                const fistL = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), fistMat), fistR = fistL.clone();
                scene.add(fistL, fistR);
                for(let i=0; i<30; i++) {
                    player.position.y += 0.55;
                    fistL.position.copy(player.position).add(new THREE.Vector3(-3.5, Math.sin(i*0.8)*1.5, 0));
                    fistR.position.copy(player.position).add(new THREE.Vector3(3.5, Math.cos(i*0.8)*1.5, 0));
                    if(i % 5 === 0) createSplashParticle(player.position);
                    await new Promise(r => setTimeout(r, 16));
                }
                await new Promise(r => setTimeout(r, 200));
                playSpecialExplosion();
                while(player.position.y > 0.5) { player.position.y -= 2.5; await new Promise(r => setTimeout(r, 10)); }
                player.position.y = 0;
                createSplashParticle(player.position, 2.0);
                const shockwaves = [];
                for(let i=0; i<3; i++) {
                    const sw = new THREE.Mesh(new THREE.TorusGeometry(1, 0.2, 16, 100), new THREE.MeshBasicMaterial({ color: INK_COLOR, transparent: true, opacity: 1 }));
                    sw.rotation.x = Math.PI/2; sw.position.copy(player.position); scene.add(sw); shockwaves.push(sw);
                }
                for (let j = 0; j < 512; j++) {
                    const angle = (j / 512) * Math.PI * 2, tilt = (Math.random() - 0.85) * Math.PI * 0.6;
                    const dir = new THREE.Vector3(Math.cos(angle), Math.sin(tilt), Math.sin(angle)).normalize();
                    raycaster.set(player.position.clone().add(new THREE.Vector3(0,1,0)), dir);
                    const hits = raycaster.intersectObjects(paintableObjects);
                    if (hits.length > 0 && hits[0].distance < 60) paintAt(hits[0].object, hits[0].uv, 4.5 * (1 - hits[0].distance / 65) + 1.5);
                }
                let swScale = 0;
                const swInt = setInterval(() => {
                    swScale += 2.0; shockwaves.forEach((sw, idx) => { const s = swScale * (1 - idx * 0.2); if(s > 0) { sw.scale.set(s, s, s); sw.material.opacity -= 0.03; } });
                    if(shockwaves[0].material.opacity <= 0) { clearInterval(swInt); shockwaves.forEach(sw => scene.remove(sw)); scene.remove(fistL, fistR); isSpecialActive = false; updateSpecialUI(); }
                }, 20);
            } else {
                // ローラー：トリプルトルネード・ストックモード
                tornadoStock = 3;
                updateSpecialUI();
                isSpecialActive = false; // 発動処理自体はすぐ終わるが、ストックを消費するまでゲージは溜まらない
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            raycaster.set(player.position.clone().add(new THREE.Vector3(0, 1, 0)), new THREE.Vector3(0, -1, 0));
            const groundHits = raycaster.intersectObjects(paintableObjects);
            const isOnInk = groundHits.length > 0 && checkInkColor(groundHits[0].object, groundHits[0].uv);
            const forwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
            const rayOrigin = player.position.clone().add(new THREE.Vector3(0, 1, 0)).add(forwardDir.clone().multiplyScalar(-0.5));
            raycaster.set(rayOrigin, forwardDir);
            const wallHits = raycaster.intersectObjects(paintableObjects.filter(o => o.userData.isWall));
            const isFacingPaintedWall = isSubmerged && wallHits.length > 0 && wallHits[0].distance < 2.0 && checkInkColor(wallHits[0].object, wallHits[0].uv);

            shooterModel.visible = (currentWeapon === 'shooter' && !isSubmerged);
            rollerModel.visible = (currentWeapon === 'roller' && !isSubmerged);
            weaponHolder.visible = !isSubmerged;

            if (!isSpecialActive) {
                const isRolling = currentWeapon === 'roller' && isShooting && !isSubmerged && player.position.y <= 0.1 && tornadoStock === 0;
                
                if (isRolling) {
                    rollerModel.position.set(-0.8, -1.2, -1.5);
                    rollerModel.rotation.x = 0;
                    for (let x = -1.2; x <= 1.2; x += 0.4) {
                        const offset = new THREE.Vector3(x, 0, -2).applyQuaternion(player.quaternion);
                        raycaster.set(player.position.clone().add(offset).add(new THREE.Vector3(0,1,0)), new THREE.Vector3(0,-1,0));
                        const hits = raycaster.intersectObjects(paintableObjects);
                        // ローラーの塗りはポイント効率を下げる
                        if (hits.length > 0) paintAt(hits[0].object, hits[0].uv, 0.4); 
                    }
                } else {
                    rollerModel.position.set(-0.8, 0, -2);
                    rollerModel.rotation.x = Math.PI/4;
                }

                let speed = isSubmerged ? (isOnInk ? 0.38 : 0.05) : (isRolling ? 0.3 : 0.18);
                body.visible = !(isSubmerged && isOnInk);
                body.scale.set(1, isSubmerged ? 0.2 : 1, 1);

                if (isFacingPaintedWall) {
                    yVelocity = 0;
                    if (move.fwd) player.position.y += 0.22;
                    if (move.bwd) player.position.y -= 0.22;
                    player.position.y = Math.max(0, player.position.y);
                    raycaster.set(player.position.clone().add(new THREE.Vector3(0, 1.2, 0)), forwardDir);
                    if (move.fwd && raycaster.intersectObjects(paintableObjects.filter(o => o.userData.isWall)).length === 0) {
                        player.position.y += 1.2; player.position.add(forwardDir.clone().multiplyScalar(2.5));
                    }
                    player.position.add(forwardDir.clone().multiplyScalar(wallHits[0].distance - 1.3));
                } else {
                    const moveVec = new THREE.Vector3();
                    if (move.fwd) moveVec.z -= 1; if (move.bwd) moveVec.z += 1;
                    if (move.lft) moveVec.x -= 1; if (move.rgt) moveVec.x += 1;
                    if (moveVec.length() > 0) {
                        moveVec.normalize().applyQuaternion(player.quaternion).multiplyScalar(speed);
                        const checkRay = new THREE.Raycaster(player.position.clone().add(new THREE.Vector3(0, 0.5, 0)), moveVec.clone().normalize(), 0, 1.2);
                        if (checkRay.intersectObjects(paintableObjects.filter(o => o.userData.isWall)).length === 0) player.position.add(moveVec);
                    }
                    player.position.y += yVelocity;
                    if (player.position.y > 0) {
                        yVelocity -= 0.012;
                        if (yVelocity < 0) {
                            raycaster.set(player.position.clone().add(new THREE.Vector3(0, 1, 0)), new THREE.Vector3(0, -1, 0));
                            const landHits = raycaster.intersectObjects(paintableObjects);
                            if (landHits.length > 0 && landHits[0].distance < 1.05) { player.position.y = landHits[0].point.y; yVelocity = 0; }
                        }
                    } else { player.position.y = 0; yVelocity = 0; }
                }
            }

            for (let i = bombs.length - 1; i >= 0; i--) {
                const b = bombs[i]; b.position.add(b.userData.velocity); b.userData.velocity.y -= 0.02;
                raycaster.set(b.position, b.userData.velocity.clone().normalize());
                if (raycaster.intersectObjects(paintableObjects).length > 0 && raycaster.intersectObjects(paintableObjects)[0].distance < 0.6) b.userData.velocity.set(0,0,0);
                b.userData.timer += 0.016; const s = 1 + Math.sin(b.userData.timer * 20) * 0.1 + (b.userData.timer / b.userData.life); b.scale.set(s, s, s);
                if (b.userData.timer >= b.userData.life) {
                    playExplosionSound();
                    for (let j = 0; j < 16; j++) {
                        const angle = (j / 16) * Math.PI * 2, dir = new THREE.Vector3(Math.cos(angle), -0.5, Math.sin(angle)).normalize();
                        raycaster.set(b.position, dir); const eHits = raycaster.intersectObjects(paintableObjects);
                        if (eHits.length > 0 && eHits[0].distance < 12) paintAt(eHits[0].object, eHits[0].uv, 3.5);
                    }
                    scene.remove(b); bombs.splice(i, 1);
                }
            }

            if (currentWeapon === 'shooter' && isShooting && !isSubmerged && !isSpecialActive && tornadoStock === 0 && Date.now() - (animate.lastShoot || 0) > 80) {
                playShootSound();
                const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshBasicMaterial({ color: INK_COLOR }));
                bullet.position.copy(player.position).add(new THREE.Vector3(0, 1.5, 0));
                const targetDir = new THREE.Vector3(); camera.getWorldDirection(targetDir);
                bullet.userData.velocity = targetDir.multiplyScalar(1.3);
                scene.add(bullet); bullets.push(bullet); animate.lastShoot = Date.now();
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i], prevPos = b.position.clone();
                b.position.add(b.userData.velocity); b.userData.velocity.y -= 0.022;
                raycaster.set(prevPos, b.position.clone().sub(prevPos).normalize());
                raycaster.far = b.position.clone().sub(prevPos).length() + 0.5;
                const hits = raycaster.intersectObjects(paintableObjects);
                if (hits.length > 0) { paintAt(hits[0].object, hits[0].uv, 1.2); scene.remove(b); bullets.splice(i, 1); }
                else if (b.position.y < -10) { scene.remove(b); bullets.splice(i, 1); }
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
